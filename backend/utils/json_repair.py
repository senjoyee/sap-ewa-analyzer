#!/usr/bin/env python3
"""
Sophisticated JSON Repair Script for LLM Output
Handles various malformed JSON issues commonly generated by LLMs.
"""

import json
import re
import logging
from typing import Any, Dict, List, Optional, Union
from dataclasses import dataclass

@dataclass
class RepairResult:
    """Result of JSON repair attempt."""
    success: bool
    data: Optional[Any] = None
    original_text: Optional[str] = None
    repaired_text: Optional[str] = None
    errors: List[str] = None
    repair_methods_used: List[str] = None
    
    def __post_init__(self):
        if self.errors is None:
            self.errors = []
        if self.repair_methods_used is None:
            self.repair_methods_used = []

class JSONRepair:
    """Sophisticated JSON repair utility for LLM-generated content."""
    
    def __init__(self, debug: bool = False):
        self.debug = debug
        if debug:
            logging.basicConfig(level=logging.DEBUG)
        self.logger = logging.getLogger(__name__)
    
    def repair(self, text: str) -> RepairResult:
        """
        Attempt to repair malformed JSON using multiple strategies.
        
        Args:
            text: The potentially malformed JSON string
            
        Returns:
            RepairResult with success status and repaired data
        """
        result = RepairResult(success=False, original_text=text)
        
        # Try parsing as-is first
        try:
            data = json.loads(text)
            result.success = True
            result.data = data
            result.repaired_text = text
            result.repair_methods_used.append("no_repair_needed")
            return result
        except json.JSONDecodeError as e:
            result.errors.append(f"Initial parse error: {e}")
        
        # Apply repair strategies in order of increasing aggressiveness
        repair_strategies = [
            self._extract_json_block,
            self._fix_common_issues,
            self._fix_quotes,
            self._fix_trailing_commas,
            self._fix_unescaped_chars,
            self._fix_incomplete_structures,
            self._aggressive_repair,
        ]
        
        current_text = text
        for strategy in repair_strategies:
            try:
                repaired_text = strategy(current_text)
                if repaired_text != current_text:
                    result.repair_methods_used.append(strategy.__name__)
                    current_text = repaired_text
                    
                # Try parsing after each repair
                try:
                    data = json.loads(current_text)
                    result.success = True
                    result.data = data
                    result.repaired_text = current_text
                    return result
                except json.JSONDecodeError:
                    continue
                    
            except Exception as e:
                result.errors.append(f"Error in {strategy.__name__}: {e}")
                continue
        
        # If all strategies failed, try one final fallback
        try:
            final_attempt = self._fallback_repair(text)
            data = json.loads(final_attempt)
            result.success = True
            result.data = data
            result.repaired_text = final_attempt
            result.repair_methods_used.append("fallback_repair")
        except Exception as e:
            result.errors.append(f"Final fallback failed: {e}")
        
        return result
    
    def _extract_json_block(self, text: str) -> str:
        """Extract JSON from code blocks or surrounding text."""
        # Remove markdown code blocks
        text = re.sub(r'^```(?:json)?\s*\n', '', text, flags=re.MULTILINE)
        text = re.sub(r'\n```\s*$', '', text, flags=re.MULTILINE)
        
        # Find JSON-like content between braces or brackets
        patterns = [
            r'(\{.*\})',  # Objects
            r'(\[.*\])',  # Arrays
        ]
        
        for pattern in patterns:
            match = re.search(pattern, text, re.DOTALL)
            if match:
                return match.group(1).strip()
        
        return text.strip()
    
    def _fix_common_issues(self, text: str) -> str:
        """Fix common JSON formatting issues."""
        # Remove comments
        text = re.sub(r'//.*$', '', text, flags=re.MULTILINE)
        text = re.sub(r'/\*.*?\*/', '', text, flags=re.DOTALL)
        
        # Fix common boolean/null values
        text = re.sub(r'\b(True|TRUE)\b', 'true', text)
        text = re.sub(r'\b(False|FALSE)\b', 'false', text)
        text = re.sub(r'\b(None|NULL|null|Null)\b', 'null', text)
        
        # Remove trailing/leading whitespace
        text = text.strip()
        
        return text
    
    def _fix_quotes(self, text: str) -> str:
        """Fix quote-related issues."""
        # Convert single quotes to double quotes (basic)
        text = re.sub(r"'([^'\\]*(?:\\.[^'\\]*)*)'", r'"\1"', text)
        
        # Fix unquoted keys (simple cases)
        text = re.sub(r'(\w+)(\s*:)', r'"\1"\2', text)
        
        # Fix missing quotes around string values (heuristic)
        text = re.sub(r':\s*([a-zA-Z_][a-zA-Z0-9_\s]*[a-zA-Z0-9_])\s*([,}\]])', r': "\1"\2', text)
        
        return text
    
    def _fix_trailing_commas(self, text: str) -> str:
        """Remove trailing commas."""
        # Remove trailing commas before closing braces/brackets
        text = re.sub(r',(\s*[}\]])', r'\1', text)
        return text
    
    def _fix_unescaped_chars(self, text: str) -> str:
        """Fix unescaped characters in strings."""
        # Fix unescaped quotes inside strings (basic heuristic)
        def escape_quotes(match):
            content = match.group(1)
            # Escape internal quotes
            content = content.replace('"', '\\"')
            return f'"{content}"'
        
        # This is a simplified approach - more sophisticated parsing would be needed for complex cases
        text = re.sub(r'"([^"]*)"', lambda m: f'"{m.group(1)}"', text)
        
        return text
    
    def _fix_incomplete_structures(self, text: str) -> str:
        """Attempt to complete incomplete JSON structures."""
        text = text.strip()
        
        # Count braces and brackets
        open_braces = text.count('{') - text.count('}')
        open_brackets = text.count('[') - text.count(']')
        
        # Add missing closing braces
        if open_braces > 0:
            text += '}' * open_braces
        
        # Add missing closing brackets
        if open_brackets > 0:
            text += ']' * open_brackets
        
        return text
    
    def _aggressive_repair(self, text: str) -> str:
        """More aggressive repair attempts."""
        # Try to extract key-value pairs and reconstruct
        lines = text.split('\n')
        pairs = []
        
        for line in lines:
            line = line.strip()
            if ':' in line:
                # Try to extract key-value pairs
                key_match = re.search(r'["\']?(\w+)["\']?\s*:', line)
                if key_match:
                    key = key_match.group(1)
                    value_part = line.split(':', 1)[1].strip().rstrip(',')
                    
                    # Clean up value
                    if value_part.startswith('"') and value_part.endswith('"'):
                        value = value_part
                    elif value_part.isdigit():
                        value = value_part
                    elif value_part.lower() in ['true', 'false', 'null']:
                        value = value_part.lower()
                    else:
                        value = f'"{value_part}"'
                    
                    pairs.append(f'"{key}": {value}')
        
        if pairs:
            return '{' + ', '.join(pairs) + '}'
        
        return text
    
    def _fallback_repair(self, text: str) -> str:
        """Last resort repair attempt."""
        # Try to create a simple object with the text as a value
        escaped_text = json.dumps(text)
        return f'{{"content": {escaped_text}}}'
    
    def repair_file(self, file_path: str, output_path: Optional[str] = None) -> RepairResult:
        """
        Repair JSON from a file.
        
        Args:
            file_path: Path to the file containing malformed JSON
            output_path: Optional path to save repaired JSON
            
        Returns:
            RepairResult with repair status and data
        """
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                text = f.read()
            
            result = self.repair(text)
            
            if result.success and output_path:
                with open(output_path, 'w', encoding='utf-8') as f:
                    json.dump(result.data, f, indent=2, ensure_ascii=False)
                self.logger.info(f"Repaired JSON saved to {output_path}")
            
            return result
            
        except Exception as e:
            return RepairResult(
                success=False,
                errors=[f"File operation error: {e}"]
            )
    
    def batch_repair(self, json_strings: List[str]) -> List[RepairResult]:
        """Repair multiple JSON strings."""
        results = []
        for i, text in enumerate(json_strings):
            self.logger.debug(f"Repairing JSON {i+1}/{len(json_strings)}")
            result = self.repair(text)
            results.append(result)
        return results

def main():
    """Example usage and CLI interface."""
    import argparse
    
    parser = argparse.ArgumentParser(description="Repair malformed JSON")
    parser.add_argument("input", nargs="?", help="Input JSON string or file path")
    parser.add_argument("-f", "--file", action="store_true", help="Treat input as file path")
    parser.add_argument("-o", "--output", help="Output file path")
    parser.add_argument("-d", "--debug", action="store_true", help="Enable debug logging")
    parser.add_argument("--test", action="store_true", help="Run test cases")
    
    args = parser.parse_args()
    
    if args.test:
        run_tests()
        return
    
    if not args.input:
        print("Please provide input JSON string or use --test to run test cases")
        return
    
    repairer = JSONRepair(debug=args.debug)
    
    if args.file:
        result = repairer.repair_file(args.input, args.output)
    else:
        result = repairer.repair(args.input)
        if result.success and args.output:
            with open(args.output, 'w', encoding='utf-8') as f:
                json.dump(result.data, f, indent=2, ensure_ascii=False)
    
    if result.success:
        print("✅ JSON repair successful!")
        print(f"Methods used: {', '.join(result.repair_methods_used)}")
        if not args.output:
            print("\nRepaired JSON:")
            print(json.dumps(result.data, indent=2, ensure_ascii=False))
    else:
        print("❌ JSON repair failed!")
        for error in result.errors:
            print(f"Error: {error}")

def run_tests():
    """Run test cases to demonstrate functionality."""
    test_cases = [
        # Valid JSON (no repair needed)
        '{"name": "John", "age": 30}',
        
        # Trailing commas
        '{"name": "John", "age": 30,}',
        
        # Single quotes
        "{'name': 'John', 'age': 30}",
        
        # Unquoted keys
        '{name: "John", age: 30}',
        
        # Comments
        '''
        {
            // This is a comment
            "name": "John", /* another comment */
            "age": 30
        }
        ''',
        
        # Incomplete structure
        '{"name": "John", "age": 30',
        
        # Markdown code block
        '''```json
        {"name": "John", "age": 30}
        ```''',
        
        # Mixed issues
        '''{
            name: 'John',  // person's name
            age: 30,
            active: True,
            data: null,
        }''',
    ]
    
    repairer = JSONRepair(debug=True)
    
    for i, test_case in enumerate(test_cases, 1):
        print(f"\n{'='*50}")
        print(f"Test Case {i}:")
        print(f"Input: {repr(test_case[:50])}{'...' if len(test_case) > 50 else ''}")
        
        result = repairer.repair(test_case)
        
        if result.success:
            print("✅ Success!")
            print(f"Methods used: {', '.join(result.repair_methods_used)}")
            print(f"Result: {json.dumps(result.data, indent=2)}")
        else:
            print("❌ Failed!")
            for error in result.errors:
                print(f"Error: {error}")

if __name__ == "__main__":
    main()